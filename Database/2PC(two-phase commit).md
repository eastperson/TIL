# Overview

DB, Message Broker, Service 등이 여러개로 분산되어있는 경우 데이터의 일관성을 유지하기 위해서 분산 트랜잭션을 이용한다. X/Open DTP(Distributed Transaction Processing, 분산 트랜잭션 처리) 모델(X/Open XA)은 분산 트랜잭션 관리의 사실상 표준이었다. 이때 XAsms 2PC(two-phase commit, 2단계 커밋)을 이용해 트랜잭션 참여자가 반드시 커밋 아니면 롤백을 할 수 있도록보장한다. 대표적으로 자바는 JTA 기술을 이용하여 분산 트랜잭션을 수행한다.

하지만 현대의 분산 트랜잭션은 이러한 방식을 이용하지 않는다. NoSQL DB, 메시지 브로커 기술은 분산 트랜잭션을 지원하지 않는다. 이외에도 동기 IPC 형태여서 가용성이 떨어지는 점도 문제가 되었다.

# 2PC(Two phase commit)

2PC는 두 개 이상의 자원(DB, Message Broker)을 한 트랜잭션으로 처리하는 방법입니다.

![image](https://user-images.githubusercontent.com/66561524/227931822-e7969149-2293-4f9d-a555-b850c4d5de20.png)

2PC 트랜잭션은 애플리케이션이 여러 데이터베이스 노드에서 데이터를 읽고 쓰는 것으로부터 시작됩니다. 커밋할 준비가 되면 각 노드에 준비 요청을 보내 커밋 가능여부를 묻는 1단계를 진행합니다. 1단계의 응답에 따라서 커밋을 할지 롤백을 할지 최종 결정을 합니다. 모든 커밋이 가능하다는 응답이 오면 트랜잭션 매니저는 2단계에서 커밋 요청을 수행합니다. 만약 불가능한 응답이 오면 모든 노드에 중단 요청을 보냅니다.

각 자원은 2PC를 지원해야하고 코디네이터(혹은 글로벌 트랜잭션 관리자)가 필요합니다. 애플리케이션에서 로컬 트랜잭션을 관리하듯이 코드를 통해 통제가 가능합니다. 다만 **지금은 거의 사용하지 않습니다.** 이유는 성능 때문입니다.

> 1. 애플리케이션이 분산 트랜잭션은 시작하길 원하면, 코디네이터에게 트랜잭션 ID를 요청합니다. 이 **트랜잭션 ID는 글로벌하게 유니크**합니다.
> 2. 애플리케이션이 각 참여자와 싱글-노드 트랜잭션을 시작하고 위의 글로벌하게 유니크한 ID를 전달합니다. 모든 읽기와 쓰기는 이러한 싱글-노드 트랜잭션 중 하나에서 처리되게 됩니다. 이 단계에서 일부 작업이 잘못되면 코디네이터 또는 참여자 중 누구도 abort할 수 있습니다.
> 3. 애플리케이션이 커밋할 준비가 되면, 코디네이터는 모든 참여자들에게 글로벌 트랜잭션 ID가 포함된 prepare 요청을 보냅니다. 이러한 요청 중 어느 하나라도 실패하거나 타임아웃되면, 코디네이터는 모든 참여자들에게 해당 트랜잭션 ID의 트랜잭션 abort 요청을 보냅니다.
> 4. 참여자가 prepare 요청을 받으면, 참여자는 어떠한 상황에서는 트랜잭션을 커밋할 수 있도록 합니다. 이것은 모든 트랜잭션 데이터를 디스크에 쓰고, 제약위반 등을 검증하는 것을 포함합니다. 코디네이터에게 'yes'를 응답하면서, 노드는 트랜잭션이 커밋된다면 어떠한 에러도 없이 커밋될 수 있다는 것을 약속합니다.
> 5. 코디네이터가 모든 prepare 요청들에 대한 응답들을 받으면, 트랜잭션을 커밋할지 abort할지 결정합니다. 코디네이터는 그러한 결정을 디스크에 존재하는 코디네이터 트랜잭션 로그에 기록하여 혹시나 발생하는 crash에 대비합니다 (commit point).
> 6. 코디네이터의 결정이 디스크에 write되고 커밋 또는 abort 요청이 모든 참여자들에게 전달됩니다. 요청이 실패하거나 타임아웃되면 코디네이터는 성공할 때까지 retry해야 합니다. 이후의 취소, 반려는 없으며 결정이 커밋하는 것이었다면 얼마의 retry가 필요하든지와 상관없이 그 결정이 강제되어야 합니다. 참여자가 그 사이에 다운되면, 참여자가 회복했을 때 그 트랜잭션은 커밋됩니다.

# 2PC의 단점

- 코디네이터가 다운되면 prepare 요청을 보내기 전에 참여자는 안전하게 abort할 수 없다.
    - 이런 상황을 피하기 위해 consensus algorithm, total order broadcast protocol 이 사용 된다.
    - 각 db들이 coordinator에게 commit 가능 여부를 보내는 것이 아니라 각 db들 간에 이 정보를 주고 받는 것
- A, B, C 각 db가 특정 transaction 의 commit 가능 여부를 주고 받는다. 헌데 한가지 유념해야할 부분은 이 경우에는 race condition 이 발생할 수 있다. A는 B, C에게 commit이 가능하다고 전달하였지만 network timeout으로 인해 B는 전달받지 못하면 B 입장에서는 Abort되어야한다고 판단. C는 A의 요청에 정상적으로 commit 이 가능하다고 전달 받은 경우가 발생

2PC은 단일 db에 비해서 (Mysql)로 비교하면 10배가량의 performance 차이가 난다고 한다. 해당 commit의 가능 여부를 network io를 이용하여 판단하기에 io로 인한 퍼포먼스 저하라고 생각하였으나 crash recovery를 위해서 추가적인 `fsync()`도 퍼포먼스 저하중 하나의 원인

- two(or more) databases from diffrent vendors서버에서 작업하다보면 특정 처리의 결과를 두개의 db에다 관련 데이터를 write하는 경우가 발생한다. 허나 2PC의 경우 performance나 구현에 들어가는 리소스를 생각했을 때, 상황에 따라서 uow 디자인 패턴을 이용하는 경우도 있다
- Exactly-once message processing 메세지큐와 해당 메세지를 처리하는 분산된 node에서 둘 다 제대로 처리되었다는 commit이 필요하다. 메세지 큐에서는 해당 메세지를 가져갔다고 commit이 되었는데 메세지를 처리하는 쪽에서는 받아서 처리되었다는 commit이 되지 않을 경우에는 메세지가 분실된다.따라서 둘 다 처리되었다고 commit 하거나, 둘 다 처리되지 않게 처리하여 메세지가 다시 처리될 수 있도록 해야한다.헌데 이 메세지 처리결과가 외부 회사에서 진행이 되는 경우, 외부 회사와 2PC를 구현하는 것은 운영 cost가 높기에 현실적으로 구현이 불가능할 수 있다. 이럴 경우 Exactly-once 가 아닌 at-least-most 방식으로 처리를 하게 되며 이 경우 메세지 중복현상이 발생한다.
