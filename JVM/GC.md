# Overview

풀(full) GC를 수행하는 시점에는 해당 JVM에서 처리되지 않는다는 단점이 있다. GC를 많이 할수록 응답 시간에 많은 영향을 끼친다. GC가 어떻게 처리되는지 기본 지식을 갖고 있어야 한다.

# GC란?

- C언어는 명시적으로 메모리를 건드리고 참조할 수 있다.
- 자바에서는 메모리를 GC라는 알고리즘을 통하여 관리하기 때문에 메모리를 처리하기 위한 로직을 만들 필요가 없고 만들어서 안된다.
- 자바에서 쓰레기는 객체이다. 하나의 객체는 메모리를 점유하고 필요하지 않으면 메모리에서 해제되어야 한다. 이 쓰레기 객체를 효과적으로 처리하는 작업을 GC라고 한다.

# 자바의 Runtime data area는 이렇게 구성된다

자바에서 사용하는 메모리 영역들에 대한 상세한 설명을 볼 수 있다.

- PC 레지스터
- JVM 스택
- 힙(Heap)
- 메서드 영역
- 런타임 상수(constant) 풀
- 네이티브 메서드 스택

![image](https://github.com/eastperson/TIL/assets/66561524/8636b3b3-ae4f-48c8-aabb-f7321224cbb0)

GC가 발생하는 부분이 힙 영역이다. 나머지 영역은 GC 대상이 아니다. ‘클래스 로더 서브 시스템'은 클래스나 인터페이스를 JVM으로 로딩하는 기능을 수행하고 ‘실행 엔진'은 로딩된 클래스의 메서드들에 포함 되어 있는 모든 인스트럭션 정보를 실행한다.

- 자바의 메모리 영역은 ‘Heap 메모리'와 ‘Non-heap’ 메모리로 나뉜다.

## Heap 메모리

클래스 인스턴스, 배열이 이 메모리에 쌓인다. 이 메모리는 ‘공유(shared) 메모리’라고도 불리우며 여러 스레드에서 공유하는 데이터들이 저장되는 메모리다. 

## Non-heap 메모리

- 메서드 영역
    - 모든 JVM 스레드에서 공유한다. 이 영역에 저장되는 데이터는 아래와 같다.
        - 런타임 상수 풀
            - 자바의 클래스 파일에는 constant_pool 이라는 정보가 포함되 어있다. 이 정보를 실행시에 참조하기 위한 영역이다.
            - 실제 상수값도 여기 포함될 수 있지만 실행시 변하게 되는 필드 참조 정보도 포함된다.
        - 필드 정보에 메서드 데이터, 메서드와 생성자 코드가 있다.
- JVM 스택
    - 스레드가 시작할 때 JVM 스택이 생성된다. 이 스택에서는 메서드가 호출되는 정보인 프레임(frame)이 저장된다. 그리고 지역 변수와 임시 결과, 메서드 수행과 리턴에 관련된 정보도 포함된다.
- 네이티브 메서드 스택
    - 자바 코드가 아닌 다른 언어로 된 코드들이 실행하게 될 때의 스택 정보를 관리한다.
- PC 레지스터
    - 자바의 스레드들은 각자 pc(Program Counter) 레지스터를 갖는다. 네이티브한 코드를 제외한 모든 자바 코드들이 수행될 때 JVM의 인스트럭션 주소를 PC 레지스터에 보관한다.  

> 스택의 크기는 고정하거나 가변적일 수 있다. 만약 연산을 하다가 JVM의 스택 크기의 최대치를 넘어섰을 경우 StackOverflowError가 발생한다. 가변적일 경우 스택의 크기를 늘이려고 할 때 메모리가 부족하거나 스레드를 생성할 때 메모리가 부족한 경우에는 OutOfMemoryError가 발생한다.

- Heap 영역과 메서드 영역은 JVM이 시작될 때 생성된다.

![image](https://github.com/eastperson/TIL/assets/66561524/fbcea40c-2795-4aa0-ae02-ade899cc87d8)

# GC의 원리

- GC 작업을 하는 가비지 콜렉터(Garbage Collector)의 역할
    - 메모리 할당
    - 사용 중인 메모리 인식
    - 사용하지 않는 메모리 인식
        - 작업을 수행하지 않으면 할당한 메모리 영역이 꽉 차서 JVM에 행(Hang)이 걸리거나 더 많은 메모리를 할당하려고 하여 문제가 생긴다. JVM의 최대 메모리 크기를 지정해서 전부 사용하고 GC를 해도 더 이상 사용 가능한 메모리 영역이 없는데 계속 메모리를 할당하려고 하면 OutOfMemoryError가 발생하여 JVM이 다운될 수 있다.

![image](https://github.com/eastperson/TIL/assets/66561524/e2fb3e05-a9ed-4b78-a098-26714c92d7e9)

- JVM Heap 메모리 구조는 크게 Young 영역(eden, survivor1, survivor2)과 Old 영역으로 구분된다. Perm 부분은 JDK 8부터 사라진다. 우리가 고려해야 할 자바의 메모리 영역은 총 4개 영역이다.

| Young 영역 | Young 영역 | Young 영역 | Old 영역 |
| --- | --- | --- | --- |
| Eden | Survivor 1 | Survivor 2 | 메모리 영역 |
- 메모리에 객체가 생성되면 그림의 가장 왼쪽인 Eden 영역에 객체가 지정된다.
- Eden 영역에 데이터가 꽉 차면 영역에 있던 객체가 옮겨지거나 삭제되어야 한다. 이 때 옮기는 위치는 Survivor 영역이다. 두 영역의 우선순위가 있는 것은 아니며 두 영역 중 한 영역은 반드시 비어있어야 한다. 비어 있는 영역에 Eden 영역에 있던 객체 중 GC 후에 살아남아 있는 객체들이 이동한다.
- Eden 영역에 있던 객체는 Survivor 영역 둘 중하나에 할당된다. 할당된 Survivor 영역이 차면 GC가 되면서 Eden 영역에 있는 객체와 꽉 찬 Survivor 영역에 있는 객체가 비어있는 Survivor 영역으로 이동한다. 이러한 작업이 반복되면서 Survivor 1과 2를 왔다 갔다 하던 객체들은 Old 영역으로 이동한다.
- Young 영역에서 Old 영역으로 넘어가는 객체 중 Survivor 영역을 거치지 않고 바로 Old 영역으로 이동하는 객체가 있을 수 있다.

# GC의 종류

---

- 마이너 GC: Young 영역에서 발생하는 GC
- 메이저 GC: Old 영역이나 Perm 영역에서 발생하는 GC

GC가 발생하거나 객체가 각 영역에서 다른 영역으로 이동할 때 애플리케이션의 병목이 발생하면서 성능에 영향을 주게 된다. 핫 스팟(Hot Spot) JVM에서는 스레드 로컬 할당 버퍼(TLABs: Thread-Local Allocation Buffers)라는 것을 사용한다. 

# 5가지 GC 방식

---

JDK 7 이상에서 지원하는 GC 방식에는 5가지가 있다.

- Serial Collector(이하 시리얼 콜렉터)
- Parallel Collector(이하 병렬 콜렉터)
- Parallel Compacting Collector(이하 병렬 콤팩팅 콜렉터)
- Concurrent Mark-Sweep (CMS) Collector (이하 CMS 콜렉터)
- Garbage First Collector(이하 G1 콜렉터)

## 시리얼 콜렉터

- Young 영역과 Old 영역이 시리얼하게(연속적으로) 처리되며 하나의 CPU를 사용한다.
- 이 처리를 수행할 때를 Stop-the-world라고 표현한다.

![image](https://github.com/eastperson/TIL/assets/66561524/d554b9dd-3410-4b3e-8c35-e11e2d87f1b4)

- 콜렉션이 수행될 때 애플리케이션 수행이 정지된다.
1. 일단 살아있는 객체들은 Eden 영역에 있다(각각의 둥근 사각형이 객체 하나라고 보면 된다)
2. Eden 영역이 꽉차게 되면 To Survivor 영역(비어 있는 영역)으로 살아있는 객체가 이동한다. 이 때 Survivor 영역에 들어가기에 너무 큰 객체는 바로 Old 영역으로 이동한다. 그리고 From Survivor 영역에 있는 살아있는 개체는 To Survivor 영역으로 이동한다.
3. To Survivor 영역이 꽉 찼을 경우, Eden 영역이나 From Survivor 영역에 남아있는 객체들은 Old 영역으로 이동한다.

Old 영역이나 Perm 영역에 있는 객체들은 Mark-sweep-compact 콜렉션 알고리즘을 따른다. 쓰이지 않는 객체를 표시해서 삭제하고 한 곳으로 모으는 알고리즘이다. Mark-sweep-compact 콜렉션 알고리즘은 다음과 같이 수행된다.

1. Old 영역으로 이동된 객체들 중 살아 있는 객체를 식별한다.
2. Old 영역의 객체들을 훑는 작업을 수행하여 쓰레기 객체를 식별한다.
3. 필요 없는 객체들을 지우고 살아 있는 객체들을 한 곳으로 모은다.

## 병렬 콜렉터

- 스루풋 콜렉터(throughput collector)로도 알려진 방식
- 다른 CPU가 대기 상태로 남아있는 것을 최소화하는 것이 목적
- 시리얼 콜렉터와 달리 Young 영역에서 콜렉션을 병렬(Parallel)로 처리한다. CPU를 많이 사용하기 때문에 GC 부하를 줄이고 애플리케이션의 처리량을 증가시킬 수 있다.
- Old 영역의 GC는 시리얼 콜렉터와 마찬가지로 Mark-sweep-compact 콜렉션 알고리즘을 사용한다.

![image](https://github.com/eastperson/TIL/assets/66561524/0c001c6e-3c0a-405c-883b-0f2fc6008888)

## 병렬 콤팩팅 콜렉터

- 병렬 콜렉터와 다른 점은 Old 영역 GC에서 새로운 알고리즘을 사용한다. Young 영역에 대한 GC는 병렬 콜렉터와 동일하지만 Old 영역의 GC는 다음 3단계를 거친다.
1. 표시 단계: 살아 있는 객체를 식별하여 표시해 놓는 단계
2. 종합 단계: 이전에 GC를 수행하여 컴팩션된 영역에 살아 있는 객체의 위츨ㄹ 조사하는 단계
3. 컴팩션 단계: 컴팩션을 수행하는 단계. 수행 이후에 컴팩션된 영역과 비어있는 영역으로 나뉜다..

- 병렬 콜렉터와 동일하게도 이 방식도 여러 CPU를 활용하는 서버에 적합하다.

<aside>
💡 시리얼 콜렉터와 병렬 콜렉터의 Old 영역의 방식과 병렬 콤팩팅 콜렉터의 Old 영역의 방식은 어떤 점이 다를까? 두 방식의 가장 큰 차이점은 스윕(sweep) 단계와 종합(Summary) 단계의 차이라고 본다.
- 스윕 단계는 단일 스레드가 Old 영역 전체를 훑는다.
- 종합 단계는 여러 스레드가 Old 영역을 분리하여 훑는다. 게다가 앞서 진행된 GC에서 컴팩션된 영역을 별도로 훑는다는 점도 다르다.

</aside>

## CMS 콜렉터

- 로우 레이턴시 콜렉터(low-latency collector)로 알려져 있다.
- 힙 메모리의 잉역의 크기가 클 때 적합하다.
- Young 영역에 대한 GC는 병렬 콜렉터와 동일하다.

Old GC는 다음 단계를 거친다.

1. 초기 표시 단계
    - 매우 짧은 대기 시간으로 살아있는 객체를 찾는 단계
2. 컨커런트 표시 단계
    - 서버 수행과 동시에 살아 있는 객체에 표시를 해놓는 단계
3. 재표시(remark) 단계
    - 컨커런트 표시 단계에서 표시하는 동안 변경된 객체에 대해서 다시 표시하는 단계
4. 컨커런트 스윕 단계
    - 표시되어 있는 쓰레기를 정리하는 단계

![image](https://github.com/eastperson/TIL/assets/66561524/0ef9c2cc-7e57-492a-87dc-6011723a33f2)
![image](https://github.com/eastperson/TIL/assets/66561524/e0c354ac-32b1-4720-b7dd-49bdb0042232)

- CMS 콜렉터 방식은 2개 이상의 프로세서를 사용하는 서버에 적당하다. 가장 적당한 대상으로는 웹 서버가 있다.
- CMS 콜렉터는 추가적인 옵션으로 점진적 방식을 지원한다.
- CMS 콜렉터는 추가적인 옵션으로 점진적 방식을 지원한다. 이 방식은 Young 영역의 GC를 더 잘게 쪼개어 서버의 대기 시간을 줄일 수 있다. CPU가 많지 않고 시스템의 대기 시간이 짧아야 할 때 사용하면 좋다.

## G1 콜렉터

- 지금까지 설명한 모든 Garbage Collector는 Eden과 Survivor 영역으로 나뉘는 Young 영역과 Old 영역으로 구성되어 있다. 하지만 Garage First(이하 G1)는 지금까지의 Garbage Collector와는 다른 영역으로 구성되어있다.

![image](https://github.com/eastperson/TIL/assets/66561524/45bf7437-4f05-4301-83a8-e75b33335616)

- 여기서 각 바둑판의 사각형을 region이라고 하는데 Young 역역이나 Old 영역이라는 단어와 구분하기 위해서 ‘구역'이라고 한다. G1은 Young 영역과 Old 영역이 물리적으로 나뉘어 있지 않고 각 구역의 크기는 모두 동일하다.
- 콜렉터들은 모두 Young과 Old 영역의 주소가 물리적으로 Linear하게 나열되지만 G1은 그렇지 않다. 구역의 개수는 약 2000개이다.

**G1이 Young GC**

1. 몇 개의 구역을 선정하여 Young 영역으로 지정한다.
2. 이 Linear하지 않은 구역에 객체가 생성되면서 데이터가 쌓인다.
3. Young 영역으로 할당된 구역에 데이터가 꽉 차면 GC를 수행한다.
4. GC를 수행하면서 살아있는 객체들만 Survivor 구역으로 이동시킨다.

Young GC가 발생하면 Survivor 영역에 계속 쌓는다. 몇 번의 aging 작업을 통해서(Survivor 영역에 있는 객체가  몇 번의 Young GC 후에도 살아 있으면 Old 영역으로 승격된다.

G1의 Old 영역 GC는 CMS GC의 방식과 비슷하며 6단계로 나뉜다. STW라고 표시된 단계에서는 모두 Stop the world가 발생한다.

- 초기 표시 (Initial Mark) 단계(STW)
    - Old 영역에 있는 객체에서 Survivor 영역의 객체를 참조하고 있는 객체를 표시한다.
- 기본 구역 스캔(Root region scanning) 단계
    - Old 영역에 있는 객체에서 Survivor 영역을 훑는다. 참고로 이 작업은 Young GC가 발생하기 전에 수행한다.
- 컨커런트 표시 단계
    - 전체 힙 영역에 살아있는 찾는다. 만약 이때 Young GC가 발생하면 잠시 멈춘다.
- 재 표시(Remark) 단계 (STW)
    - 힙에 있는 살아있는 객체들의 표시 작업을 완료한다. 이 때 snapshot-at-the-beginning (SATB)라는 알고리즘을 사용하며 이는 CMS GC에서 사용하는 방식보다 빠르다.
- 청소 (Cleaning) 단계 (STW)
    - 살아있는 객체와 비어있는 구역을 식별하고 필요 없는 개체들을 지운다. 그리고 나서 비어있는 구역을 초기화한다.
- 복사 단계 (STW)
    - 살아있는 객체들을 비어 있는 구역으로 모은다.

- GC는 아무때나 하는 것이아니라 각 영역에 할당된 크기의 메모리가 허용치를 넘을 때 수행한다는 것이다.
