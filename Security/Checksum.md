# Checksum(검사합)

- 데이터의 오류 여부 확인 방법으로 널리 사용된다.
    
> 원본 → 복사본 으로 전송을 한 경우 그 두 데이터가 동일한 데이터인지 확인할 때 사용된다. 원본을 어떠한 함수를 통해 checksum을 만들어서 같이 전송을 한 뒤 복사본도 어떠한 함수를 통해 checksum을 만들었을 때 둘이 일치하면 손상되지 않은 동일한 데이터라고 판단한다.
    
    - 보안성은 없다. (정보보안의 3원칙)
        - 무결성
            - 복사본의 일부 데이터를 변경하고 checksum으로 넘어온 값을 재계산 해버리면 바꿔치기 할 수 있다.
                - 이 문제를 해결하기 위해 Hash
        - 기밀성
        - 가용성
- 일정 자릿수를 정하고 범위를 넘는 자리 올림은 버려서 자릿수를 유지한다.
    - 자리 올림을 사사시킨다.
    - 한자릿수 일 때
        - ex) 5 + 7 = 2
    - 두자릿수 일 때
        - ex) 55 +79 = 34

![image](https://user-images.githubusercontent.com/66561524/215908253-3ac23af5-acb6-4cb8-947e-89e8be8a460c.png)

- 원본문자 → f(x) → 획수
    - 단방향
    - 획수로 원본문자를 유추할 수 없다.
- ASCII 코드
    - 대문자 ‘`A`’는 65로 표현할 수 있다.
    - 그래서 검사할 때 문제가 없다.

https://www.notion.so/SSL-933f4d930cd74f6787d7ea09ee19fa97

# Checksum 특징

  ㅇ 방법
     - 송신측에서, 전송할 모든 데이터를 16 비트 워드 단위로 구분하고,  
     - 1의 보수를 취하고, 그 합에 대한 결과를 전송하면, 
     - 수신측에서, 같은 합을 해보아서 오류를 검출하는 방식
     
     
> 보수(補數)는 보충을 해주는 수를 의미한다. 이를테면 1에 대한 10의 보수는 9, 4에 대한 15의 보수는 11의 개념이다. 2에 대한 1의 보수는 1이다.


2. 검사합 특징

  ㅇ 보통, 16 비트 워드 단위로 검사합을 주로 사용
  ㅇ 간단한 방식이기는 하나, 워드의 순서가 바꾸어지는 오류에 대한 검출은 하지 못함

  ㅇ 데이터링크계층에서는, 점차 사용하지 않고, 보다 강력한 CRC로 대체되는 추세
  ㅇ 그 상위계층에서는, S/W 구현 편리성으로 아직 일부 사용중 
     - 네트워크계층의 IP 헤더 
        . (IPv4 헤더에는 있으나, IPv6 헤더에는 체크섬 필드 없어짐)
     - 전송계층의 TCP 헤더나 UDP 헤더 등에 일부 사용  ☞ UDP 체크섬, TCP 체크섬 참조

3. 16 비트 워드 검사합 방법

  ㅇ 송신측
     - 메세지를 16 비트 워드로 구분
     - 검사합 워드의 초기값을 0으로 둠
     - 검사합을 포함한 모든 워드에 1의 보수를 취하고 이를 더함
     - 그 최종값을 검사합으로 함
     - 그 검사합을 데이터와 함께 송신

  ㅇ 수신측
     - 검사합이 포함된 수신 메세지를 16 비트 워드 단위로 구분
     - 모든 워드에 1의 보수를 취하고 더함
     - 그 최종값을 새로운 검사합으로 보고,
     - 검사합의 값이 0 이면 오류 없음, 0 이 아니면 오류 있음

예시
4 바이트의 데이터가 있다. 0x25, 0x62, 0x3F, 0x52

1단계 : 모든 바이트를 덧셈하면 0x118 이 된다.
2단계 : 캐리 니블(1바이트의 절반으로 보통 4비트를 가리키는 컴퓨터 환경의 용어)을 버림으로써 0x18을 만든다.
3단계 : 0x18의 2의 보수를 얻어 0xE8을 얻는데 이것이 바로 체크섬 바이트이다.
체크섬 바이트를 테스트하려면 원래의 그룹의 바이트에 체크섬 바이트까지 더하면 0x200이 된다.
다시 캐리 니블을 버림으로써 0x00이 된다. 0x00이라는 뜻은 오류가 없다는 뜻인데 오류가 있어도 우연히 될 수도 있다.
-출처 wikipedia
